\chapter{MicroPython firmware pro ESP32}
\label{ch:firmware}

V~této kapitole bude popsán návrh a implementace řídícího softwaru, tzv. firmwaru pro čipy ESP32 -- od základního
jádra zodpovědného za zavedení aplikací či připojení k~brokeru MQTT až k~aplikacím a jejich asynchronnímu principu.

\section{Základní požadavky pro jádro firmwaru}\label{sec:základní-požadavky-pro-jádro}
Na základě navrženého protokolu a vlastního úsudku jsem navrhl následující požadavky na implementaci jádra firmwaru:

\begin{itemize}
    \item Jádro je koncový bod pro komunikační linku s~nástrojem Node-RED -- zpracování příchozích zpráv deleguje na
    aplikace.
    \item Jádro je zodpovědné za správu připojení k~internetu, potažmo brokeru MQTT, včetně přihlašovacích údajů.
    \item Jádro má ve správě asynchronní smyčku s~požadavky aplikací.
    \item Jádro je zodpovědné za restartování uzlu v~případě neočekávaného chybového stavu.
    \item Jádro hlásí stav připojení uzlu k~síti a spravuje sběr logů z~uzlu, které následně odesílá do příslušných
    kanálů.
\end{itemize}

\section{Detaily z~implementace jádra}\label{sec:detaily-z-implementace-jadra}
V~této kapitole budou představeny a popsány některé důležité implementační detaily jádra firmwaru.
Středobodem z~hlediska funkce je asynchronní smyčka událostí, jejíž implementace pochází z~veřejně dostupného balíčku
\texttt{micropython-async}\footnote{\url{https://github.com/peterhinch/micropython-async}}.
Princip této smyčky vychází ze standardního balíku modulu \ic{asyncio} programovacího jazyka Python a nabízí
jejím uživatelům přístup k~konkurentně asynchronnímu kódu -- na nejvyšší úrovni programátor definuje pouze jednotlivé
korutiny\footnote{Korutina (coroutine) je z~pohledu asynchronního přístupu k~programování podpogram,
jehož kód lze provádět asynchronně a zároveň má možnost jiný kód tohoto typu invokovat.} (coroutines) a smyčka samotná
se stará o~rozdělování procesorového času a kontextu.

Vstupní bod pro zavedení jádra je metoda \ic{Core.start}, která dělá jedinou věc -- do inicializované smyčky zavede
korutinu \ic{Core._run}, která je zodpovědná za připojení uzlu k~síti.
Obě tyto metody lze vidět v~ukázce~\ref{code:firmware-core-start}, kde lze v~rámci druhé zmíněné také upozornit na
práci s~atributem \ic{_status_led}.
V~tomto atributu je uložena instance třídy \ic{Signal}\footnote{Třída \ic{Signal} je vyšší abstrakcí pro hardwarový pin
GPIO než, v~kapitole~\ref{sec:micropython} zmíněná, třída \ic{Pin} -- prvně jmenovaná podporuje i piny \uv{aktivní
v~0}.} nad pinem s~číslem $2$, na který je připojena na vývojové desce modrá LED dioda, s~pomocí které uzel
realizuje stavový barevný kód -- tento kód jsem navrhl pro snažší testování a ladění uzlů, jeho popis se shrnut
v~tabulce~\ref{table:esp32-state-key}.

\begin{table}
    \centering
    \begin{tabularx}{\textwidth}{@{}ccs@{}}
        \toprule
        \textbf{červená stavová dioda} & \textbf{modrá stavová dioda} & \textbf{notifikovaný stav uzlu} \\
        \midrule
        nesvítí & -- & uzel není připojen k~napájení \\
        \midrule
        svítí & nesvítí & uzel běží a čeká na zprávy či naplánované úlohy \\
        \midrule
        svítí & bliká nepravidelně & uzel zpracovává zprávy či je odesílá \\
        \midrule
        svítí & bliká s~periodou 0,5 s~& uzel se připojuje k~WiFi a brokeru \\
        \midrule
        svítí & svítí & chyba firmwaru \\
        \bottomrule
    \end{tabularx}
    \caption{Popis barevného stavového kódu uzlu -- na základě chování dvou vestavěných LED diod lze odpozorovat
    chování uzlu a jeho stav.}
    \label{table:esp32-state-key}
\end{table}

% @formatter:off
\begin{code}[
    language=Python,
    caption={Metody jádra firmwaru -- blokující metoda \ic{start} je vstupní bod jádra z~hlediska veřejného
    rozhraní, je zodpovědná za rozběhnutí smyčky událostí a naplánování běhové korutiny \ic{_run}.
    Té poté stačí pouze zaktivovat klienta připojení k~internetu, veškeré další operace již obstarává klient.},
    label=code:firmware-core-start
]
class Core:
    def start(self):
        self._loop.create_task(self._run())
        self._loop.run_forever()

    async def _run(self):
        self._status_led.on()
        try:
            await self._connection.connect()
        except OSError as e:
            print('Connection failed: {}.'.format(str(e)))
            return
        self._status_led.off()
    (*\ldots*)
\end{code}
% @formatter:on

\todo{Uspavani jadra, odber}
\blind{2}

\section{Aplikace a jejich programová struktura}\label{sec:aplikace-a-jejich-programova-struktura}



\section{Implementace vstupní aplikace}\label{sec:implementace-vstupni-aplikace}
Vstupní aplikací je z hlediska IoT sítě aplikace, která s pomocí ovladače některé z periférií získá data a dále je
distribuuje do sítě pomocí protokolu MQTT.
V ukázce~\ref{code:dht-sensor-app} se nachází kód vstupní aplikace pro export dat ze senzoru DHT, který měří okolní
teplotu a vlhkost a jehož ovladač je obsažen ve standardní distribuci jazyka MicroPython.m
Jedním z jeho specifik je neblokující chování při požadavku na změření, je tedy nutné po požadavku počkat
2-3 sekundy, než dojde k exportu hodnot. \todo{citace vole}
V případě selhání komunikace se senzorem dojde ze strany ovladače k vyhození výjimky \ic{OSError}, na kterou aplikace
reaguje zalogováním chybového stavu a počkáním na další interal měření.
Díky použití asynchronní smyčky události není nutné v korutině \ic{_run_measurement} při čekání na další měření
používat aktivní čekání, které by blokovalo kontext procesoru pro další aplikace.
Základní struktura vstupních aplikací založena na dvou metodách:
\begin{itemize}
    \item Korutina \ic{init} má na starost načtení konfigurace pro aplikaci, inicializaci ovladačů a zavedení
    měřící korutiny do asynchronní smyčky. Měla by být schopna na základě jiné konfigurace (jiného obsahu atributu
    \ic{_config}) přijmout novou konfiguraci a reinicializovat ovladače a celkové nastavení.
    \item Metoda \ic{_plan_app_task} slouží k registraci aplikační smyčky do asynchronní smyčky jádra -- v případě
    rekonfigurace je v její kompetenci resetovat již běžící aplikační korutinu a odstranit její další naplánování ve
    smyčce, aby mohlo dojít k opětovnému naplánování při reinicializaci aplikace.nn
\end{itemize}

% @formatter:off
\begin{code}[
    language=Python,
    caption={Implementace vstupní aplikace pro měření teploty a vlhkosti pomocí senzoru DHT -- inicializační metoda
    \ic{init} načítá parametry z přijaté konfigurace a inicializuje řadič pro DHT senzor.
    Asynchronní měřící smyčka následně požádá ovladač o změření, počká a vyexportuje data.
    \textit{Kód aplikace je pro zachování jednoduchosti zkrácen a upraven.}},
    label=code:dht-sensor-app
]
class App(BaseApp):
    _dht = _interval = None
    MEASURE_EXPORT_DELAY = 3

    async def init(self):
        self._dht = dht.DHT22(Pin(self._config.get('port')))
        self._interval = self._config.get('interval')

        self._plan_app_task(self._run_measurement())

    async def _run_measurement(self):
        while True:
            try:
                self._dht.measure()
            except OSError as e:
                await self._error(e)
                await asyncio.sleep(self._interval)
                continue

            await asyncio.sleep(self.MEASURE_EXPORT_DELAY)
            await self._publish(dict(
                temperature=self._dht.temperature(),
                humidity=self._dht.humidity(),
            ), 'data')  # custom data subtopic

            await asyncio.sleep(self._interval)
\end{code}
% @formatter:on

\section{Implementace výstupní aplikace}\label{subsec:implementace-vystupni-aplikace}

Výstupní aplikace je aplikací, které reaguje na příchozí zprávy ve svém kanálu MQTT a reaguje na ně pomocí ovladačů
periférií uzlu. Příkladem uvedeným v~ukázce~\ref{code:np-display-app} je výstupní aplikace řídící displej složený z~LED
diod technologie NeoPixel \cite{Esp32KolbansBook}.
Z hlediska porovnání se vstupní aplikací se jedná o jednodušší implementaci, vzhledem k tomu, že aplikace není povinna
aktivně sledovat kanál MQTT, ale činí to za ni jádro. Kromě již zmíněné korutiny \ic{init}, ve které inicializuje
ovladač k displeji se zde nachází korutina \ic{process} zodpovědná za zpracování zprávy.
Kromě parametru \ic{payload} se samotným osahem zprávy uloženém ve slovníku příjmá korutina i parametr obsahující
seznam podkanálů, ve kterých zpráva přišla -- tyto subkanály jsou relativní vůči adresaci aplikace\footnote{Subkanály
předané do korutiny \ic{process} pro příchozí kanál \ic{fis/to/NODE_ID/app/APP_ID/sub1/sub2} jsou uloženy v seznamu
jako \ic{[\'sub1\', \'sub2\']} -- aplikace může použít tuto informaci k bližší specifikaci zprávy.}.

\begin{code}[
    language=Python,
    caption={Ukázka z implementace výstupní aplikace.},
    label=code:np-display-app
]
class App(BaseApp):
    _display = _color = None

    async def init(self):
        width = int(self._config.get('width'))
        height = int(self._config.get('height'))

        self._display = NeoPixelDisplay(
            neopixel.NeoPixel(
                machine.Pin(self._config.get('port'), mode=Pin.OUT),
                width * height,  # total count of LEDs
            ),
            width, height,
            first_line_backward=True,
        )
        self._color = self._color or 0b00100101  # low white by default

    async def process(self, payload: dict, subtopics: list):
        if payload.get('color'):
            self._color = self._display.rgb_to_color(\*payload.get('color'))

        if payload.get('text'):
            self._display.fill(0)
            self._display.compact_text(
                text=payload.get('text'),
                x=0,
                y=1,
                color=self._color,
            )
            self._display.show()

\end{code}

\subsection{Detail implementace aplikace}
\todo{Jedna nazorna aplikace}


